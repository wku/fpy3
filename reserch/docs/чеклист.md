Вот **чеклист** для реализации специализированного API-сервера **только на HTTP/3 + WebTransport** с использованием стека **msquic + nghttp3 + libwtf** (на языке C).  
Чеклист структурирован по этапам, от подготовки до продакшен-готовности. Всё ориентировано на максимальную производительность и минимальный оверхед.

### 1. Подготовка зависимостей и сборки
- [ ] Скачать и собрать **msquic** (последняя версия с GitHub microsoft/msquic)
- [ ] Собрать msquic с нужными опциями: `-DQUIC_BUILD_SHARED=OFF`, `-DQUIC_ENABLE_LOGGING=ON` (для отладки), BBRv2 по умолчанию
- [ ] Скачать и собрать **nghttp3** (nghttp2/nghttp3)
- [ ] Скачать **libwtf** (github.com/andrewmd5/libwtf) — обратить внимание: early development, не production-ready
- [ ] Слинковать все три библиотеки в свой проект (статически предпочтительнее)
- [ ] Настроить CMake / Makefile для кросс-платформенной сборки (Linux/Windows/macOS)

### 2. Глобальная инициализация
- [ ] Вызвать `MsQuicOpen()` → получить MsQuic API table
- [ ] Настроить глобальные настройки msquic (`MsQuicSetSettings`):
  - Включить 0-RTT resumption
  - Включить connection migration
  - Выбрать congestion control: BBRv2 (рекомендуется для максимальной производительности)
  - Установить idle timeout (например, 30–60 сек)
- [ ] Инициализировать TLS-конфиг (сертификат + приватный ключ через `MsQuicCredentialConfig`)
- [ ] Создать и настроить **libwtf** контекст (wtf_ctx_new или аналог из libwtf API)

### 3. Запуск слушателя (только UDP)
- [ ] Создать UDP-сокет (не TCP!)
- [ ] Зарегистрировать слушатель: `MsQuicListenerOpen` + `MsQuicListenerStart`
- [ ] Указать ALPN-лист: только `"h3"` (без h2, http/1.1)
- [ ] Включить WebTransport support: отправлять `SETTINGS_ENABLE_WEBTRANSPORT` = 1 (libwtf обычно делает это автоматически — проверить!)
- [ ] Настроить обработчик новых соединений (CONNECTION_CONNECTED callback)

### 4. Обработка соединения (connection level)
- [ ] В CONNECTION_CONNECTED:
  - Создать nghttp3_conn: `nghttp3_conn_server_new` + callbacks (on_header, on_data, on_stream_close и т.д.)
  - Привязать nghttp3 к msquic: через nghttp3 callbacks на send/recv
  - Создать WebTransport сессию через libwtf (wtf_session или wtf_transport_new)
- [ ] Реализовать проверку Origin (Sec-WebTransport-Origin или аналог) — как CORS
- [ ] Настроить обработку ошибок и shutdown: `MsQuicConnectionShutdown`

### 5. Обработка стрима и HTTP/3 запросов
- [ ] В STREAM_START / PEER_STREAM_CREATED:
  - Привязать стрим к nghttp3: `nghttp3_conn_bind_stream`
- [ ] Для обычных HTTP/3 запросов (не CONNECT):
  - Собирать заголовки и тело через nghttp3 callbacks
  - Создавать `fpy.Request` из HTTP/3 фреймов
  - Генерировать ответ → `nghttp3_conn_submit_response` → `MsQuicStreamSend`
- [ ] Отключить поддержку upgrade / CONNECT для обычных путей (если не нужен)

### 6. WebTransport сессия (самая важная часть)
- [ ] Обнаружить extended CONNECT:
  - `:method` = CONNECT
  - `:scheme` = https
  - `:path` = /твой_путь_для_wt
  - Заголовок `Sec-WebTransport: ?1`
- [ ] Через libwtf подтвердить сессию (wtf_session_accept или аналог)
- [ ] Создать внутреннюю структуру `FpyWebTransportSession`:
  - Хранить session_id, msquic connection, wtf_session, app_context
  - Хранить map активных стримов (bidirectional / unidirectional)
- [ ] Реализовать callbacks от libwtf:
  - on_session_established
  - on_bidi_stream_open (новый bidirectional stream от клиента)
  - on_unidi_stream_incoming (сервер → клиент unidirectional)
  - on_datagram_received (unreliable datagrams)
  - on_stream_reset / on_stream_close
- [ ] Реализовать отправку:
  - Bidirectional: `wtf_stream_send` / write
  - Unidirectional (server-initiated): `wtf_session_create_unidi_stream`
  - Datagram: `wtf_session_send_datagram`

### 7. Применение к твоей бизнес-логике (fpy.Request адаптация)
- [ ] Для HTTP/3 → классический `fpy.Request` / `fpy.Response` (без upgrade)
- [ ] Для WebTransport → новая модель:
  - Сессионный handler (on_session_open / on_session_close)
  - Stream handler (on_stream_data / on_stream_close)
  - Datagram handler (очень быстрый путь, без гарантий доставки/порядка)
- [ ] Реализовать backpressure: мониторить flow control msquic и останавливать чтение при переполнении

### 8. Безопасность и отказы
- [ ] Проверять Origin строго (reject если не разрешён)
- [ ] Обрабатывать все reset/error коды msquic/nghttp3/libwtf
- [ ] Отправлять 403/400/429 при ошибках negotiation
- [ ] Настроить rate limiting на уровне соединения/сессии

### 9. Тестирование и метрики (обязательно!)
- [ ] Тесты на Chrome/Edge (WebTransport API)
- [ ] Тесты на потерю пакетов, handover сети, high BDP
- [ ] Метрики: 
  - % 0-RTT соединений
  - Кол-во стримов/сессию
  - Datagram loss rate
  - CPU / throughput под нагрузкой (wrk / h2load с QUIC)
- [ ] Логирование: msquic trace + свой app-level log

### 10. Продакшен-готовность
- [ ] Проверить стабильность libwtf под нагрузкой (если крашится — патчить или перейти на lsquic)
- [ ] Настроить graceful shutdown
- [ ] Добавить мониторинг (Prometheus или свой)
- [ ] Подумать о fallback-плане (отдельный порт с HTTP/2 + WS на будущее)

Этот чеклист покрывает ~90% необходимого.  
Самые сложные и времязатратные пункты — интеграция libwtf (callbacks, quirks браузеров) и обработка WebTransport сессий/datagrams под твой use-case.

Если уточнишь, какой именно тип трафика (чат, игры, telemetry, RPC и т.д.), я могу сделать подчеклист именно под него (например, приоритет datagrams или reliable streams).