# План доработок и рефакторинга проекта FPY

Этот документ описывает утвержденный план модернизации проекта, направленный на повышение производительности, улучшение наблюдаемости и поддержку современных протоколов.

---

## 1. Рефакторинг и Оптимизация

### 1.1. Динамический пул памяти (Dynamic Memory Pool)
**Текущее состояние:** Размер пула `REQUEST_FREELIST_MAX` жестко задан (1024), что ограничивает масштабируемость.
**План реализации:**
1.  **Изменение C-структуры:** Модифицировать `Request_new` и `Request_dealloc` в `crequest.c`.
2.  **Конфигурация:** Добавить возможность задавать размер пула при инициализации приложения (`fpy.Application(..., max_requests=5000)`).
3.  **Автоматическое масштабирование:** Реализовать логику, при которой пул может временно расширяться под нагрузкой и сжиматься при простое (soft/hard limits).
4.  **Риски и контроль:**
    - *Фрагментация памяти:* При частом выделении/освобождении больших блоков.
    - *Оверхед:* Усложнение логики аллокатора может добавить такты CPU. Требуется бенчмаркинг.

### 1.2. Асинхронное структурное логирование
**Текущее состояние:** Синхронные `print` вызовы, блокирующие I/O и цикл событий.
**План реализации:**
1.  **Интеграция:** Внедрить `structlog` или стандартный `logging` с асинхронным хендлером (через отдельный thread/process или queue listener).
2.  **Замена Print:** Удалить все `print()` из `app/__init__.py` и C-кода (перенаправление `printf` из C в Python logger через callback).
3.  **Формат:** JSON-формат логов для удобного парсинга (ELK/Datadog).

### 1.3. Type Hinting (Stubs)
**Текущее состояние:** Отсутствие типизации для C-модулей.
**План реализации:**
1.  Создать файлы `.pyi` для модулей:
    - `fpy.protocol.cprotocol`
    - `fpy.request.crequest`
    - `fpy.router.cmatcher`
2.  Настроить `mypy` в CI для проверки соответствия.

---

## 2. Внедрение HTTP/3 (QUIC)

**Стратегия:** Нативная реализация на C для сохранения максимальной производительности, с использованием библиотек `msquic` (транспорт) и `nghttp3` (семантика HTTP/3).

### Архитектура решения

#### Компоненты
1.  **msquic (Microsoft QUIC):** Кроссплатформенная библиотека на C. Берет на себя UDP-сокеты, шифрование (TLS 1.3), контроль перегрузки и потоки QUIC.
2.  **nghttp3:** Библиотека C для деокодирования/кодирования фреймов HTTP/3 и сжатия заголовков QPACK.
3.  **С-Glue Layer (Новый модуль `cquic`):** Прослойка, связывающая `uvloop`, `msquic` и Python API.

#### Схема интеграции
1.  **Event Loop Integration:**
    - `msquic` работает через callback-и. Необходимо прокинуть эти коллбеки в Python `uvloop` или запускать `msquic` в отдельном потоке, передавая готовые `Request` объекты в основной цикл через потокобезопасную очередь.
    - *Альтернатива:* Использовать polling-режим `msquic`, если он доступен, и интегрировать файловый дескриптор в `uvloop` (сложно, так как msquic абстрагирует сокеты). **Рекомендуется вариант с отдельным I/O потоком для QUIC engine.**

2.  **Обработка запроса (Request Creation):**
    - `nghttp3` парсит данные из QUIC-стрима.
    - При получении заголовков создается объект `fpy.Request` (через новый C-API метод `Request_from_python` или аналогичный, заполняющий структуру напрямую).
    - Объект `Request` передается в существующий `Router`.

3.  **Обработка ответа:**
    - `Router` возвращает `Response`.
    - `nghttp3` кодирует ответ в HTTP/3 фреймы.
    - `msquic` отправляет данные в UDP поток.

### План работ

#### Фаза 1: Сборка зависимостей
- Подготовить скрипты сборки для `msquic` и `nghttp3` (статическая линковка или shared libs).
- Обеспечить совместимость с Linux окружением (OpenSSL версии).

#### Фаза 2: Прототип (Echo Server)
- Создать минимальный C-модуль, поднимающий QUIC сервер на порту.
- Реализовать простой "рукопожатие" и прием данных.

#### Фаза 3: Интеграция с FPY
- Подключить `nghttp3` для разбора HTTP семантики.
- Связать полученные данные с Python-obj `Request`.
- Реализовать обратный поток данных (Response -> QUIC).

### Ожидаемые результаты
- Поддержка HTTP/3 "из коробки".
- Производительность сопоставимая или превышающая TCP реализацию (zero-rrt, отсутствие head-of-line blocking).
- Полная совместимость с текущими хендлерами и роутером.
