# Анализ архитектуры проекта FPY

## Общий обзор
FPY — это высокопроизводительный асинхронный веб-фреймворк для Python, ориентированный на максимальную скорость обработки запросов за счет использования C-расширений (CPython C API). Архитектурно проект напоминает Japronto, используя те же принципы: кастомный протокол на C, управление памятью через пулы объектов и тесная интеграция с `uvloop`.

## Модульная структура

### 1. `src/fpy/app`
Основная точка входа. Класс `Application` управляет:
- **Жизненным циклом сервера:** Запуск `uvloop`, обработка сигналов (SIGTERM, SIGINT).
- **Воркерами:** Использование `multiprocessing` для запуска нескольких процессов-обработчиков, разделяющих один сокет (`SO_REUSEADDR`).
- **Конфигурацией:** Настройки роутера, протокола, логирования.
- **Очисткой:** Метод `drain` для корректного завершения соединений.

### 2. `src/fpy/c_impl` & C-расширения
Ключевая особенность проекта — "теневая" реализация критических компонентов на C.
- **`protocol/c_impl`**: Реализация HTTP протокола.
- **`request/c_impl`**: Объекты запроса (`Request`).
- **`response/c_impl`**: Объекты ответа (`Response`).
- **`router/c_impl`**: Логика маршрутизации (`Matcher`).

### 3. `src/fpy/router`
Маршрутизация реализована гибридно:
- **Python (`route.py`, `matcher.py`):** Определение маршрутов, компиляция паттернов.
- **C (`cmatcher.c`):** Скомпилированные маршруты преобразуются в плоский буфер для быстрого поиска. Поддерживаются точные совпадения (`SEGMENT_EXACT`) и плейсхолдеры (`SEGMENT_PLACEHOLDER`).

## Ключевые механизмы

### Работа с памятью
В `src/fpy/request/c_impl/crequest.c` реализован собственный менеджер памяти для объектов `Request`:
- Используется статический массив `request_freelist` размером 1024 элемента.
- При создании запроса (`Request_new`) объект берется из пула, если он не пуст.
- При удалении (`Request_dealloc`) объект возвращается в пул, избегая вызовов системного аллокатора.
- Буферы данных (`buffer`) могут использовать инлайн-память (`inline_buffer`) для небольших запросов или динамически аллоцироваться (`malloc`/`realloc`) для больших.

### Асинхронность и Event Loop
- Проект жестко завязан на `uvloop` (в `app/__init__.py` явно вызывается `uvloop.new_event_loop()`).
- Используется `loop.create_server` для TCP соединений.
- `Protocol` (`cprotocol.c`) взаимодействует с циклом событий, создавая задачи (`loop.create_task`) для асинхронных обработчиков (корутин).
- Реализован механизм `Pipeline` для поддержки HTTP pipelining: запросы ставятся в очередь, ответы отправляются в строгом порядке, даже если обработка асинхронна.

### Реализация HTTP
- **Парсинг:** Используется `picohttpparser` (упоминается в `crequest.c` и структуре папок) — быстрый С-парсер HTTP заголовков.
- **Обработка протокола (`cprotocol.c`):**
    - `Protocol_on_headers`: Инициализирует запрос.
    - `Protocol_on_body`: Завершает формирование запроса, выполняет матчинг маршрута и вызывает обработчик.
    - **Keep-Alive:** Поддержка постоянных соединений с логикой определения версии HTTP (1.0 vs 1.1).
    - **Pipelining:** Поддержка очереди запросов/ответов.

## Выводы
Проект представляет собой узкоспециализированное решение для HighLoad задач. Основной упор сделан на минимизацию оверхеда Python при обработке HTTP.
